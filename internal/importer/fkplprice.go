package importer

import (
	"context"
	"database/sql"
	"log"
	"time"
)

func RunMkplPriceFinalize(
	ctx context.Context,
	dbConn *sql.DB,
	processID string,
) error {

	start := time.Now()
	log.Println("Import MKPL PRICE FINAL started")

	ctx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	tx, err := dbConn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	query := `
	SET NOCOUNT ON;

	DECLARE @SummaryOfChanges TABLE (
		ACTION VARCHAR(10)
	);

	WITH CTE_MPD AS (
		SELECT
			ISNULL(fm.UNIT1, '') AS UOM1,
			ISNULL(fm.UNIT2, '') AS UOM2,
			ISNULL(fm.UNIT3, '') AS UOM3,
			ISNULL(fm.UNIT4, '') AS UOM4,
			ISNULL(fm.UNIT5, '') AS UOM5,
			ISNULL(fm.CONVUNIT2, 1) AS CON2,
			ISNULL(fm.CONVUNIT3, 1) AS CON3,
			ISNULL(fm.CONVUNIT4, 1) AS CON4,
			ISNULL(fm.CONVUNIT5, 1) AS CON5,
			mpd.PRICE_UOM AS PRICE_UOM,
			mpd.PRICE_VALUE AS PRICE_VAL,
			'' AS KODECABANG,
			mpd.CUST_CODE AS CUSTNO,
			mpd.PCODE AS PCODE,
			'' AS MG3,
			CASE mpd.PRICE_UOM WHEN fm.UNIT5 THEN mpd.PRICE_VALUE  ELSE 0 END AS SELLPRICE1,
			CASE mpd.PRICE_UOM WHEN fm.UNIT4 THEN mpd.PRICE_VALUE  WHEN fm.UNIT5 THEN mpd.PRICE_VALUE  *  fm.CONVUNIT2 ELSE 0 END AS SELLPRICE2,
			CASE mpd.PRICE_UOM WHEN fm.UNIT3 THEN mpd.PRICE_VALUE WHEN fm.UNIT4 THEN mpd.PRICE_VALUE *  fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE *  fm.CONVUNIT3 *  fm.CONVUNIT2 ELSE 0 END AS SELLPRICE3,
			CASE mpd.PRICE_UOM WHEN fm.UNIT2 THEN mpd.PRICE_VALUE WHEN fm.UNIT3 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 WHEN fm.UNIT4 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 *  fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 *  fm.CONVUNIT3 *  fm.CONVUNIT2 ELSE 0 END AS SELLPRICE4,
			CASE mpd.PRICE_UOM WHEN fm.UNIT1 THEN mpd.PRICE_VALUE WHEN fm.UNIT2 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 WHEN fm.UNIT3 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 WHEN fm.UNIT4 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 *  fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 *  fm.CONVUNIT3 *  fm.CONVUNIT2 ELSE 0 END AS SELLPRICE5,
			0 AS BUYPRICE1,
			0 AS BUYPRICE2,
			0 AS BUYPRICE3,
			0 AS BUYPRICE4,
			0 AS BUYPRICE5,
			mpd.CDATE AS CREATED_DATE,
			mpd.UNIQ_ID AS CREATED_BY,
			mpd.MDATE AS UPDATED_DATE,
			mpd.UNIQ_ID AS UPDATED_BY
		FROM
			dbo.mkplprice_dummy AS mpd
		INNER JOIN dbo.fmaster AS fm ON mpd.PCODE = fm.PCODE
		WHERE mpd.UNIQ_ID = @UNIQ_ID
	)

	MERGE dbo.fkpl_price WITH (HOLDLOCK) AS TARGET
	USING CTE_MPD AS SOURCE
	ON (
		TARGET.CUSTNO = SOURCE.CUSTNO
		AND	TARGET.PCODE = SOURCE.PCODE
		AND TARGET.KODECABANG = SOURCE.KODECABANG
	)
	WHEN MATCHED THEN UPDATE SET
		TARGET.SELLPRICE1 = SOURCE.SELLPRICE1,
		TARGET.SELLPRICE2 = SOURCE.SELLPRICE2,
		TARGET.SELLPRICE3 = SOURCE.SELLPRICE3,
		TARGET.SELLPRICE4 = SOURCE.SELLPRICE4,
		TARGET.SELLPRICE5 = SOURCE.SELLPRICE5,
		TARGET.CREATED_DATE = SOURCE.CREATED_DATE,
		TARGET.CREATED_BY = SOURCE.CREATED_BY,
		TARGET.UPDATED_DATE = SOURCE.UPDATED_DATE,
		TARGET.UPDATED_BY = SOURCE.UPDATED_BY
	WHEN NOT MATCHED THEN INSERT (
		KODECABANG, CUSTNO, PCODE, SELLPRICE1, SELLPRICE2, SELLPRICE3, SELLPRICE4, SELLPRICE5, CREATED_DATE, CREATED_BY, UPDATED_DATE, UPDATED_BY
	)
	VALUES (
		SOURCE.KODECABANG, SOURCE.CUSTNO, SOURCE.PCODE, SOURCE.SELLPRICE1, SOURCE.SELLPRICE2, SOURCE.SELLPRICE3, SOURCE.SELLPRICE4, SOURCE.SELLPRICE5,
		SOURCE.CREATED_DATE, SOURCE.CREATED_BY, SOURCE.UPDATED_DATE, SOURCE.UPDATED_BY
	)
	OUTPUT $action INTO @SummaryOfChanges;

	SELECT
		SUM(CASE WHEN ACTION = 'INSERT' THEN 1 ELSE 0 END),
		SUM(CASE WHEN ACTION = 'UPDATE' THEN 1 ELSE 0 END)
	FROM @SummaryOfChanges;
	`

	var inserted, updated int
	if err := tx.QueryRowContext(ctx, query, sql.Named("UNIQ_ID", processID)).Scan(&inserted, &updated); err != nil {
		return err
	}

	if err := tx.Commit(); err != nil {
		return err
	}

	log.Printf(
		"PRICE FINAL completed | inserted=%d updated=%d duration=%s",
		inserted,
		updated,
		time.Since(start),
	)

	return nil
}
