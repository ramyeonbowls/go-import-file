package importer

import (
	"context"
	"database/sql"
	"log"
	"time"
)

func RunMPriceFinalize(
	ctx context.Context,
	dbConn *sql.DB,
	processID string,
) error {

	start := time.Now()
	log.Println("Import PRICE FINAL started")

	ctx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	tx, err := dbConn.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()

	query := `
	SET NOCOUNT ON;

	DECLARE @SummaryOfChanges TABLE (
		ACTION VARCHAR(10)
	);

	WITH CTE_MPD AS (
		SELECT
			ISNULL(fm.UNIT1, '') AS UOM1,
			ISNULL(fm.UNIT2, '') AS UOM2,
			ISNULL(fm.UNIT3, '') AS UOM3,
			ISNULL(fm.UNIT4, '') AS UOM4,
			ISNULL(fm.UNIT5, '') AS UOM5,
			ISNULL(fm.CONVUNIT2, 1) AS CON2,
			ISNULL(fm.CONVUNIT3, 1) AS CON3,
			ISNULL(fm.CONVUNIT4, 1) AS CON4,
			ISNULL(fm.CONVUNIT5, 1) AS CON5,
			mpd.PRICE_UOM,
			mpd.PRICE_VALUE,
			'' AS KODECABANG,
			mpd.PRICE_CODE AS GHARGA,
			mpd.PCODE,
			'' AS MG3,
			CASE mpd.PRICE_UOM WHEN fm.UNIT5 THEN mpd.PRICE_VALUE ELSE 0 END AS SELPRICE1,
			CASE mpd.PRICE_UOM WHEN fm.UNIT4 THEN mpd.PRICE_VALUE WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT2 ELSE 0 END AS SELPRICE2,
			CASE mpd.PRICE_UOM WHEN fm.UNIT3 THEN mpd.PRICE_VALUE WHEN fm.UNIT4 THEN mpd.PRICE_VALUE * fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT3 * fm.CONVUNIT2 ELSE 0 END AS SELPRICE3,
			CASE mpd.PRICE_UOM WHEN fm.UNIT2 THEN mpd.PRICE_VALUE WHEN fm.UNIT3 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 WHEN fm.UNIT4 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 * fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT4 * fm.CONVUNIT3 * fm.CONVUNIT2 ELSE 0 END AS SELPRICE4,
			CASE mpd.PRICE_UOM WHEN fm.UNIT1 THEN mpd.PRICE_VALUE WHEN fm.UNIT2 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 WHEN fm.UNIT3 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 WHEN fm.UNIT4 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 * fm.CONVUNIT3 WHEN fm.UNIT5 THEN mpd.PRICE_VALUE * fm.CONVUNIT5 * fm.CONVUNIT4 * fm.CONVUNIT3 * fm.CONVUNIT2 ELSE 0 END AS SELPRICE5,
			0 AS BUYPRICE1,
			0 AS BUYPRICE2,
			0 AS BUYPRICE3,
			0 AS BUYPRICE4,
			0 AS BUYPRICE5,
			mpd.CDATE,
			mpd.UNIQ_ID,
			mpd.MDATE
		FROM dbo.m_price_dummy mpd
		INNER JOIN dbo.fmaster fm ON mpd.PCODE = fm.PCODE
		WHERE mpd.UNIQ_ID = @UNIQ_ID
	)

	MERGE dbo.fprice WITH (HOLDLOCK) AS TARGET
	USING CTE_MPD AS SOURCE
	ON (
		TARGET.KODECABANG = SOURCE.KODECABANG
		AND TARGET.GHARGA = SOURCE.GHARGA
		AND TARGET.PCODE = SOURCE.PCODE
		AND TARGET.MG3 = SOURCE.MG3
	)
	WHEN MATCHED THEN UPDATE SET
		SELPRICE1 = SOURCE.SELPRICE1,
		SELPRICE2 = SOURCE.SELPRICE2,
		SELPRICE3 = SOURCE.SELPRICE3,
		SELPRICE4 = SOURCE.SELPRICE4,
		SELPRICE5 = SOURCE.SELPRICE5,
		BUYPRICE1 = 0,
		BUYPRICE2 = 0,
		BUYPRICE3 = 0,
		BUYPRICE4 = 0,
		BUYPRICE5 = 0,
		UPDATED_DATE = SOURCE.MDATE,
		UPDATED_BY = SOURCE.UNIQ_ID
	WHEN NOT MATCHED THEN INSERT (
		KODECABANG, GHARGA, PCODE, MG3,
		SELPRICE1, SELPRICE2, SELPRICE3, SELPRICE4, SELPRICE5,
		BUYPRICE1, BUYPRICE2, BUYPRICE3, BUYPRICE4, BUYPRICE5,
		CREATED_DATE, CREATED_BY, UPDATED_DATE, UPDATED_BY
	)
	VALUES (
		SOURCE.KODECABANG, SOURCE.GHARGA, SOURCE.PCODE, SOURCE.MG3,
		SOURCE.SELPRICE1, SOURCE.SELPRICE2, SOURCE.SELPRICE3, SOURCE.SELPRICE4, SOURCE.SELPRICE5,
		0,0,0,0,0,
		SOURCE.CDATE, SOURCE.UNIQ_ID, SOURCE.MDATE, SOURCE.UNIQ_ID
	)
	OUTPUT $action INTO @SummaryOfChanges;

	SELECT
		SUM(CASE WHEN ACTION = 'INSERT' THEN 1 ELSE 0 END),
		SUM(CASE WHEN ACTION = 'UPDATE' THEN 1 ELSE 0 END)
	FROM @SummaryOfChanges;
	`

	var inserted, updated int
	if err := tx.QueryRowContext(ctx, query, sql.Named("UNIQ_ID", processID)).Scan(&inserted, &updated); err != nil {
		return err
	}

	if err := tx.Commit(); err != nil {
		return err
	}

	log.Printf(
		"PRICE FINAL completed | inserted=%d updated=%d duration=%s",
		inserted,
		updated,
		time.Since(start),
	)

	return nil
}
